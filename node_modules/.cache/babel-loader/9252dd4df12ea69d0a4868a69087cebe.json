{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nfunction ignoreFunction() {}\n\nfunction createReturningFunction(value) {\n  return function () {\n    return value;\n  };\n}\n\nfunction Parser(states) {\n  this.states = this.compileStates(states);\n}\n\nParser.prototype.compileStates = function (states) {\n  var result = {};\n  Object.keys(states).forEach(function (name) {\n    result[name] = this.compileState(states[name], states);\n  }, this);\n  return result;\n};\n\nParser.prototype.compileState = function (state, states) {\n  var regExps = [];\n\n  function iterator(str, value) {\n    regExps.push({\n      groups: Parser.getGroupCount(str),\n      regExp: str,\n      value: value\n    });\n  }\n\n  function processState(statePart) {\n    if (Array.isArray(statePart)) {\n      statePart.forEach(processState);\n    } else if (typeof statePart === \"object\") {\n      Object.keys(statePart).forEach(function (key) {\n        iterator(key, statePart[key]);\n      });\n    } else if (typeof statePart === \"string\") {\n      processState(states[statePart]);\n    } else {\n      throw new Error(\"Unexpected 'state' format\");\n    }\n  }\n\n  processState(state);\n  var total = regExps.map(function (r) {\n    return \"(\" + r.regExp + \")\";\n  }).join(\"|\");\n  var actions = [];\n  var pos = 1;\n  regExps.forEach(function (r) {\n    var fn;\n\n    if (typeof r.value === \"function\") {\n      fn = r.value;\n    } else if (typeof r.value === \"string\") {\n      fn = createReturningFunction(r.value);\n    } else {\n      fn = ignoreFunction;\n    }\n\n    actions.push({\n      name: r.regExp,\n      fn: fn,\n      pos: pos,\n      pos2: pos + r.groups + 1\n    });\n    pos += r.groups + 1;\n  });\n  return {\n    regExp: new RegExp(total, \"g\"),\n    actions: actions\n  };\n};\n\nParser.getGroupCount = function (regExpStr) {\n  return new RegExp(\"(\" + regExpStr + \")|^$\").exec(\"\").length - 2;\n};\n\nParser.prototype.parse = function (initialState, string, context) {\n  context = context || {};\n  var currentState = initialState;\n  var currentIndex = 0;\n\n  for (;;) {\n    var state = this.states[currentState];\n    var regExp = state.regExp;\n    regExp.lastIndex = currentIndex;\n    var match = regExp.exec(string);\n    if (!match) return context;\n    var actions = state.actions;\n    currentIndex = state.regExp.lastIndex;\n\n    for (var i = 0; i < actions.length; i++) {\n      var action = actions[i];\n\n      if (match[action.pos]) {\n        var ret = action.fn.apply(context, Array.prototype.slice.call(match, action.pos, action.pos2).concat([state.regExp.lastIndex - match[0].length, match[0].length]));\n\n        if (ret) {\n          if (!(ret in this.states)) throw new Error(\"State '\" + ret + \"' doesn't exist\");\n          currentState = ret;\n        }\n\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = Parser;","map":{"version":3,"sources":["/Users/George/Documents/billy/node_modules/fastparse/lib/Parser.js"],"names":["ignoreFunction","createReturningFunction","value","Parser","states","compileStates","prototype","result","Object","keys","forEach","name","compileState","state","regExps","iterator","str","push","groups","getGroupCount","regExp","processState","statePart","Array","isArray","key","Error","total","map","r","join","actions","pos","fn","pos2","RegExp","regExpStr","exec","length","parse","initialState","string","context","currentState","currentIndex","lastIndex","match","i","action","ret","apply","slice","call","concat","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nfunction ignoreFunction() {}\n\nfunction createReturningFunction(value) {\n\treturn function() {\n\t\treturn value;\n\t};\n}\n\nfunction Parser(states) {\n\tthis.states = this.compileStates(states);\n}\n\nParser.prototype.compileStates = function(states) {\n\tvar result = {};\n\tObject.keys(states).forEach(function(name) {\n\t\tresult[name] = this.compileState(states[name], states);\n\t}, this);\n\treturn result;\n};\n\nParser.prototype.compileState = function(state, states) {\n\tvar regExps = [];\n\tfunction iterator(str, value) {\n\t\tregExps.push({\n\t\t\tgroups: Parser.getGroupCount(str),\n\t\t\tregExp: str,\n\t\t\tvalue: value\n\t\t});\n\t}\n\tfunction processState(statePart) {\n\t\tif(Array.isArray(statePart)) {\n\t\t\tstatePart.forEach(processState);\n\t\t} else if(typeof statePart === \"object\") {\n\t\t\tObject.keys(statePart).forEach(function(key) {\n\t\t\t\titerator(key, statePart[key]);\n\t\t\t});\n\t\t} else if(typeof statePart === \"string\") {\n\t\t\tprocessState(states[statePart]);\n\t\t} else {\n\t\t\tthrow new Error(\"Unexpected 'state' format\");\n\t\t}\n\t}\n\tprocessState(state);\n\tvar total = regExps.map(function(r) {\n\t\treturn \"(\" + r.regExp + \")\";\n\t}).join(\"|\");\n\tvar actions = [];\n\tvar pos = 1;\n\tregExps.forEach(function(r) {\n\t\tvar fn;\n\t\tif(typeof r.value === \"function\") {\n\t\t\tfn = r.value;\n\t\t} else if(typeof r.value === \"string\") {\n\t\t\tfn = createReturningFunction(r.value);\n\t\t} else {\n\t\t\tfn = ignoreFunction;\n\t\t}\n\t\tactions.push({\n\t\t\tname: r.regExp,\n\t\t\tfn: fn,\n\t\t\tpos: pos,\n\t\t\tpos2: pos + r.groups + 1\n\t\t});\n\t\tpos += r.groups + 1;\n\t});\n\treturn {\n\t\tregExp: new RegExp(total, \"g\"),\n\t\tactions: actions\n\t};\n};\n\nParser.getGroupCount = function(regExpStr) {\n\treturn new RegExp(\"(\" + regExpStr + \")|^$\").exec(\"\").length - 2;\n};\n\nParser.prototype.parse = function(initialState, string, context) {\n\tcontext = context || {};\n\tvar currentState = initialState;\n\tvar currentIndex = 0;\n\tfor(;;) {\n\t\tvar state = this.states[currentState];\n\t\tvar regExp = state.regExp;\n\t\tregExp.lastIndex = currentIndex;\n\t\tvar match = regExp.exec(string);\n\t\tif(!match) return context;\n\t\tvar actions = state.actions;\n\t\tcurrentIndex = state.regExp.lastIndex;\n\t\tfor(var i = 0; i < actions.length; i++) {\n\t\t\tvar action = actions[i];\n\t\t\tif(match[action.pos]) {\n\t\t\t\tvar ret = action.fn.apply(context, Array.prototype.slice.call(match, action.pos, action.pos2).concat([state.regExp.lastIndex - match[0].length, match[0].length]));\n\t\t\t\tif(ret) {\n\t\t\t\t\tif(!(ret in this.states))\n\t\t\t\t\t\tthrow new Error(\"State '\" + ret + \"' doesn't exist\");\n\t\t\t\t\tcurrentState = ret;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = Parser;\n"]},"metadata":{},"sourceType":"script"}