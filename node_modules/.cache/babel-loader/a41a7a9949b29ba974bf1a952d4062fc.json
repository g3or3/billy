{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _postcss = require('postcss');\n\nvar _postcss2 = _interopRequireDefault(_postcss);\n\nvar _icssReplaceSymbols = require('icss-replace-symbols');\n\nvar _icssReplaceSymbols2 = _interopRequireDefault(_icssReplaceSymbols);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nvar matchValueDefinition = /(?:\\s+|^)([\\w-]+):?\\s+(.+?)\\s*$/g;\nvar matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\nvar options = {};\nvar importIndex = 0;\n\nvar createImportedName = options && options.createImportedName || function (importName\n/*, path*/\n) {\n  return 'i__const_' + importName.replace(/\\W/g, '_') + '_' + importIndex++;\n};\n\nexports.default = _postcss2.default.plugin('postcss-modules-values', function () {\n  return function (css, result) {\n    var importAliases = [];\n    var definitions = {};\n\n    var addDefinition = function addDefinition(atRule) {\n      var matches = void 0;\n\n      while (matches = matchValueDefinition.exec(atRule.params)) {\n        var _matches = matches;\n\n        var _matches2 = _slicedToArray(_matches, 3);\n\n        var\n        /*match*/\n        key = _matches2[1];\n        var value = _matches2[2]; // Add to the definitions, knowing that values can refer to each other\n\n        definitions[key] = (0, _icssReplaceSymbols.replaceAll)(definitions, value);\n        atRule.remove();\n      }\n    };\n\n    var addImport = function addImport(atRule) {\n      var matches = matchImports.exec(atRule.params);\n\n      if (matches) {\n        var _matches3 = _slicedToArray(matches, 3);\n\n        var\n        /*match*/\n        aliases = _matches3[1];\n        var path = _matches3[2]; // We can use constants for path names\n\n        if (definitions[path]) path = definitions[path];\n        var imports = aliases.replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, '$1').split(/\\s*,\\s*/).map(function (alias) {\n          var tokens = matchImport.exec(alias);\n\n          if (tokens) {\n            var _tokens = _slicedToArray(tokens, 3);\n\n            var\n            /*match*/\n            theirName = _tokens[1];\n            var _tokens$ = _tokens[2];\n            var myName = _tokens$ === undefined ? theirName : _tokens$;\n            var importedName = createImportedName(myName);\n            definitions[myName] = importedName;\n            return {\n              theirName: theirName,\n              importedName: importedName\n            };\n          } else {\n            throw new Error('@import statement \"' + alias + '\" is invalid!');\n          }\n        });\n        importAliases.push({\n          path: path,\n          imports: imports\n        });\n        atRule.remove();\n      }\n    };\n    /* Look at all the @value statements and treat them as locals or as imports */\n\n\n    css.walkAtRules('value', function (atRule) {\n      if (matchImports.exec(atRule.params)) {\n        addImport(atRule);\n      } else {\n        if (atRule.params.indexOf('@value') !== -1) {\n          result.warn('Invalid value definition: ' + atRule.params);\n        }\n\n        addDefinition(atRule);\n      }\n    });\n    /* We want to export anything defined by now, but don't add it to the CSS yet or\n     it well get picked up by the replacement stuff */\n\n    var exportDeclarations = Object.keys(definitions).map(function (key) {\n      return _postcss2.default.decl({\n        value: definitions[key],\n        prop: key,\n        raws: {\n          before: \"\\n  \"\n        }\n      });\n    });\n    /* If we have no definitions, don't continue */\n\n    if (!Object.keys(definitions).length) return;\n    /* Perform replacements */\n\n    (0, _icssReplaceSymbols2.default)(css, definitions);\n    /* Add export rules if any */\n\n    if (exportDeclarations.length > 0) {\n      var exportRule = _postcss2.default.rule({\n        selector: ':export',\n        raws: {\n          after: \"\\n\"\n        }\n      });\n\n      exportRule.append(exportDeclarations);\n      css.prepend(exportRule);\n    }\n    /* Add import rules */\n\n\n    importAliases.reverse().forEach(function (_ref) {\n      var path = _ref.path;\n      var imports = _ref.imports;\n\n      var importRule = _postcss2.default.rule({\n        selector: ':import(' + path + ')',\n        raws: {\n          after: \"\\n\"\n        }\n      });\n\n      imports.forEach(function (_ref2) {\n        var theirName = _ref2.theirName;\n        var importedName = _ref2.importedName;\n        importRule.append({\n          value: theirName,\n          prop: importedName,\n          raws: {\n            before: \"\\n  \"\n          }\n        });\n      });\n      css.prepend(importRule);\n    });\n  };\n});\nmodule.exports = exports['default'];","map":{"version":3,"sources":["/Users/George/Documents/billy/node_modules/css-modules-loader-core/node_modules/postcss-modules-values/lib/index.js"],"names":["Object","defineProperty","exports","value","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","_postcss","require","_postcss2","_interopRequireDefault","_icssReplaceSymbols","_icssReplaceSymbols2","obj","__esModule","default","matchImports","matchValueDefinition","matchImport","options","importIndex","createImportedName","importName","replace","plugin","css","result","importAliases","definitions","addDefinition","atRule","matches","exec","params","_matches","_matches2","key","replaceAll","remove","addImport","_matches3","aliases","path","imports","split","map","alias","tokens","_tokens","theirName","_tokens$","myName","importedName","Error","walkAtRules","indexOf","warn","exportDeclarations","keys","decl","prop","raws","before","exportRule","rule","selector","after","append","prepend","reverse","forEach","_ref","importRule","_ref2","module"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _postcss = require('postcss');\n\nvar _postcss2 = _interopRequireDefault(_postcss);\n\nvar _icssReplaceSymbols = require('icss-replace-symbols');\n\nvar _icssReplaceSymbols2 = _interopRequireDefault(_icssReplaceSymbols);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nvar matchValueDefinition = /(?:\\s+|^)([\\w-]+):?\\s+(.+?)\\s*$/g;\nvar matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\nvar options = {};\nvar importIndex = 0;\nvar createImportedName = options && options.createImportedName || function (importName /*, path*/) {\n  return 'i__const_' + importName.replace(/\\W/g, '_') + '_' + importIndex++;\n};\n\nexports.default = _postcss2.default.plugin('postcss-modules-values', function () {\n  return function (css, result) {\n    var importAliases = [];\n    var definitions = {};\n\n    var addDefinition = function addDefinition(atRule) {\n      var matches = void 0;\n      while (matches = matchValueDefinition.exec(atRule.params)) {\n        var _matches = matches;\n\n        var _matches2 = _slicedToArray(_matches, 3);\n\n        var /*match*/key = _matches2[1];\n        var value = _matches2[2];\n        // Add to the definitions, knowing that values can refer to each other\n\n        definitions[key] = (0, _icssReplaceSymbols.replaceAll)(definitions, value);\n        atRule.remove();\n      }\n    };\n\n    var addImport = function addImport(atRule) {\n      var matches = matchImports.exec(atRule.params);\n      if (matches) {\n        var _matches3 = _slicedToArray(matches, 3);\n\n        var /*match*/aliases = _matches3[1];\n        var path = _matches3[2];\n        // We can use constants for path names\n\n        if (definitions[path]) path = definitions[path];\n        var imports = aliases.replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, '$1').split(/\\s*,\\s*/).map(function (alias) {\n          var tokens = matchImport.exec(alias);\n          if (tokens) {\n            var _tokens = _slicedToArray(tokens, 3);\n\n            var /*match*/theirName = _tokens[1];\n            var _tokens$ = _tokens[2];\n            var myName = _tokens$ === undefined ? theirName : _tokens$;\n\n            var importedName = createImportedName(myName);\n            definitions[myName] = importedName;\n            return { theirName: theirName, importedName: importedName };\n          } else {\n            throw new Error('@import statement \"' + alias + '\" is invalid!');\n          }\n        });\n        importAliases.push({ path: path, imports: imports });\n        atRule.remove();\n      }\n    };\n\n    /* Look at all the @value statements and treat them as locals or as imports */\n    css.walkAtRules('value', function (atRule) {\n      if (matchImports.exec(atRule.params)) {\n        addImport(atRule);\n      } else {\n        if (atRule.params.indexOf('@value') !== -1) {\n          result.warn('Invalid value definition: ' + atRule.params);\n        }\n\n        addDefinition(atRule);\n      }\n    });\n\n    /* We want to export anything defined by now, but don't add it to the CSS yet or\n     it well get picked up by the replacement stuff */\n    var exportDeclarations = Object.keys(definitions).map(function (key) {\n      return _postcss2.default.decl({\n        value: definitions[key],\n        prop: key,\n        raws: { before: \"\\n  \" }\n      });\n    });\n\n    /* If we have no definitions, don't continue */\n    if (!Object.keys(definitions).length) return;\n\n    /* Perform replacements */\n    (0, _icssReplaceSymbols2.default)(css, definitions);\n\n    /* Add export rules if any */\n    if (exportDeclarations.length > 0) {\n      var exportRule = _postcss2.default.rule({\n        selector: ':export',\n        raws: { after: \"\\n\" }\n      });\n      exportRule.append(exportDeclarations);\n      css.prepend(exportRule);\n    }\n\n    /* Add import rules */\n    importAliases.reverse().forEach(function (_ref) {\n      var path = _ref.path;\n      var imports = _ref.imports;\n\n      var importRule = _postcss2.default.rule({\n        selector: ':import(' + path + ')',\n        raws: { after: \"\\n\" }\n      });\n      imports.forEach(function (_ref2) {\n        var theirName = _ref2.theirName;\n        var importedName = _ref2.importedName;\n\n        importRule.append({\n          value: theirName,\n          prop: importedName,\n          raws: { before: \"\\n  \" }\n        });\n      });\n\n      css.prepend(importRule);\n    });\n  };\n});\nmodule.exports = exports['default'];"]},"metadata":{},"sourceType":"script"}