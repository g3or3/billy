{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return']) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError('Invalid attempt to destructure non-iterable instance');\n    }\n  };\n}();\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _postcss = require('postcss');\n\nvar _postcss2 = _interopRequireDefault(_postcss);\n\nvar declWhitelist = ['composes'],\n    declFilter = new RegExp('^(' + declWhitelist.join('|') + ')$'),\n    matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/,\n    icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\n\nvar processor = _postcss2['default'].plugin('modules-extract-imports', function (options) {\n  return function (css) {\n    var imports = {},\n        importIndex = 0,\n        createImportedName = options && options.createImportedName || function (importName\n    /*, path*/\n    ) {\n      return 'i__imported_' + importName.replace(/\\W/g, '_') + '_' + importIndex++;\n    }; // Find any declaration that supports imports\n\n\n    css.walkDecls(declFilter, function (decl) {\n      var matches = decl.value.match(matchImports);\n      var tmpSymbols = undefined;\n\n      if (matches) {\n        var _matches = _slicedToArray(matches, 5);\n\n        var\n        /*match*/\n        symbols = _matches[1];\n        var doubleQuotePath = _matches[2];\n        var singleQuotePath = _matches[3];\n        var _global = _matches[4];\n\n        if (_global) {\n          // Composing globals simply means changing these classes to wrap them in global(name)\n          tmpSymbols = symbols.split(/\\s+/).map(function (s) {\n            return 'global(' + s + ')';\n          });\n        } else {\n          (function () {\n            var path = doubleQuotePath || singleQuotePath;\n            imports[path] = imports[path] || {};\n            tmpSymbols = symbols.split(/\\s+/).map(function (s) {\n              if (!imports[path][s]) {\n                imports[path][s] = createImportedName(s, path);\n              }\n\n              return imports[path][s];\n            });\n          })();\n        }\n\n        decl.value = tmpSymbols.join(' ');\n      }\n    }); // If we've found any imports, insert or append :import rules\n\n    var existingImports = {};\n    css.walkRules(function (rule) {\n      var matches = icssImport.exec(rule.selector);\n\n      if (matches) {\n        var _matches2 = _slicedToArray(matches, 3);\n\n        var\n        /*match*/\n        doubleQuotePath = _matches2[1];\n        var singleQuotePath = _matches2[2];\n        existingImports[doubleQuotePath || singleQuotePath] = rule;\n      }\n    });\n    Object.keys(imports).reverse().forEach(function (path) {\n      var rule = existingImports[path];\n\n      if (!rule) {\n        rule = _postcss2['default'].rule({\n          selector: ':import(\"' + path + '\")',\n          raws: {\n            after: \"\\n\"\n          }\n        });\n        css.prepend(rule);\n      }\n\n      Object.keys(imports[path]).forEach(function (importedSymbol) {\n        rule.append(_postcss2['default'].decl({\n          value: importedSymbol,\n          prop: imports[path][importedSymbol],\n          raws: {\n            before: \"\\n  \"\n          }\n        }));\n      });\n    });\n  };\n});\n\nexports['default'] = processor;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["/Users/George/Documents/billy/node_modules/css-modules-loader-core/node_modules/postcss-modules-extract-imports/lib/index.js"],"names":["Object","defineProperty","exports","value","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","_interopRequireDefault","obj","__esModule","_postcss","require","_postcss2","declWhitelist","declFilter","RegExp","join","matchImports","icssImport","processor","plugin","options","css","imports","importIndex","createImportedName","importName","replace","walkDecls","decl","matches","match","tmpSymbols","_matches","symbols","doubleQuotePath","singleQuotePath","_global","split","map","s","path","existingImports","walkRules","rule","exec","selector","_matches2","keys","reverse","forEach","raws","after","prepend","importedSymbol","append","prop","before","module"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _postcss = require('postcss');\n\nvar _postcss2 = _interopRequireDefault(_postcss);\n\nvar declWhitelist = ['composes'],\n    declFilter = new RegExp('^(' + declWhitelist.join('|') + ')$'),\n    matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/,\n    icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\n\nvar processor = _postcss2['default'].plugin('modules-extract-imports', function (options) {\n  return function (css) {\n    var imports = {},\n        importIndex = 0,\n        createImportedName = options && options.createImportedName || function (importName /*, path*/) {\n      return 'i__imported_' + importName.replace(/\\W/g, '_') + '_' + importIndex++;\n    };\n\n    // Find any declaration that supports imports\n    css.walkDecls(declFilter, function (decl) {\n      var matches = decl.value.match(matchImports);\n      var tmpSymbols = undefined;\n      if (matches) {\n        var _matches = _slicedToArray(matches, 5);\n\n        var /*match*/symbols = _matches[1];\n        var doubleQuotePath = _matches[2];\n        var singleQuotePath = _matches[3];\n        var _global = _matches[4];\n\n        if (_global) {\n          // Composing globals simply means changing these classes to wrap them in global(name)\n          tmpSymbols = symbols.split(/\\s+/).map(function (s) {\n            return 'global(' + s + ')';\n          });\n        } else {\n          (function () {\n            var path = doubleQuotePath || singleQuotePath;\n            imports[path] = imports[path] || {};\n            tmpSymbols = symbols.split(/\\s+/).map(function (s) {\n              if (!imports[path][s]) {\n                imports[path][s] = createImportedName(s, path);\n              }\n              return imports[path][s];\n            });\n          })();\n        }\n        decl.value = tmpSymbols.join(' ');\n      }\n    });\n\n    // If we've found any imports, insert or append :import rules\n    var existingImports = {};\n    css.walkRules(function (rule) {\n      var matches = icssImport.exec(rule.selector);\n      if (matches) {\n        var _matches2 = _slicedToArray(matches, 3);\n\n        var /*match*/doubleQuotePath = _matches2[1];\n        var singleQuotePath = _matches2[2];\n\n        existingImports[doubleQuotePath || singleQuotePath] = rule;\n      }\n    });\n\n    Object.keys(imports).reverse().forEach(function (path) {\n\n      var rule = existingImports[path];\n      if (!rule) {\n        rule = _postcss2['default'].rule({\n          selector: ':import(\"' + path + '\")',\n          raws: { after: \"\\n\" }\n        });\n        css.prepend(rule);\n      }\n      Object.keys(imports[path]).forEach(function (importedSymbol) {\n        rule.append(_postcss2['default'].decl({\n          value: importedSymbol,\n          prop: imports[path][importedSymbol],\n          raws: { before: \"\\n  \" }\n        }));\n      });\n    });\n  };\n});\n\nexports['default'] = processor;\nmodule.exports = exports['default'];"]},"metadata":{},"sourceType":"script"}